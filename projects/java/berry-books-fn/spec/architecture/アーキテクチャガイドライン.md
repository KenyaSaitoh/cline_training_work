# アーキテクチャガイドライン

## 1. 目的

本書は、Jakarta EE 10を基盤としたWebアプリケーション開発における標準的な処理方式を定義し、プロジェクト間で一貫性のあるアーキテクチャを実現することを目的とする。

## 2. 適用範囲

- Jakarta EE 10以上を使用するWebアプリケーション
- JPA（Jakarta Persistence）を使用するデータベースアクセスを伴うシステム
- JSF（Jakarta Server Faces）またはJAX-RS（RESTful Web Services）を使用するプレゼンテーション層

---

## 3. アーキテクチャ基本方針

### 3.1 レイヤーアーキテクチャ

システムは以下の4層構造を基本とする。

```
┌─────────────────────────────────────┐
│  プレゼンテーション層                │  ← Managed Bean / Resource
│  (Presentation Layer)                │     ユーザーインタフェース・API制御
└─────────────────────────────────────┘
           ↓ 依存（@Inject）
┌─────────────────────────────────────┐
│  ビジネスロジック層                   │  ← Service
│  (Business Logic Layer)              │     業務ロジック・トランザクション境界
└─────────────────────────────────────┘
           ↓ 依存（@Inject）
┌─────────────────────────────────────┐
│  データアクセス層                     │  ← DAO (Data Access Object)
│  (Data Access Layer)                 │     CRUD操作・クエリ実行
└─────────────────────────────────────┘
           ↓ 依存（@PersistenceContext）
┌─────────────────────────────────────┐
│  データモデル層                       │  ← Entity / DTO
│  (Data Model Layer)                  │     データ構造定義
└─────────────────────────────────────┘
```

### 3.2 依存関係の原則

- **上位層から下位層への単方向依存**：下位層は上位層を参照してはならない
- **同一レイヤー内での依存は最小化**：必要に応じて別サービスへの依存は許容されるが、循環参照は禁止
- **インターフェース分離**：必要に応じてServiceにインターフェースを定義し、実装を抽象化する

### 3.3 責務の分離

各レイヤーは明確に責務を分離し、他レイヤーの責務を侵害してはならない。

| レイヤー | 責務 | 禁止事項 |
|---------|------|----------|
| Presentation | 入力受付、画面遷移制御、表示用データ変換 | 直接的なDB操作、ビジネスルール実装 |
| Business Logic | ビジネスルール実装、トランザクション境界定義、複数DAOの調整 | 直接的なDB操作、HTTPリクエスト処理 |
| Data Access | CRUD操作、クエリ実行、エンティティ管理 | ビジネスルール実装、トランザクション制御 |
| Data Model | データ構造定義、リレーションシップ定義 | 処理ロジック（計算・検証はプロパティレベルに留める） |

---

## 4. コンポーネント設計方式

### 4.1 パッケージ構成標準

機能別にパッケージを分割し、レイヤーごとに明確な構造を持たせる。

```
[root-package]/
├── common/          # 共通クラス（ユーティリティ、Enum、定数）
├── web/             # プレゼンテーション層（JSF用）
│   ├── [feature]/   # 機能別パッケージ
│   └── filter/      # Servlet Filter
├── resource/        # プレゼンテーション層（REST API用）
├── service/         # ビジネスロジック層
│   └── [feature]/   # 機能別パッケージ
│       ├── *Service.java
│       ├── *ServiceIF.java
│       ├── *Exception.java
│       └── *TO.java
├── dao/             # データアクセス層
├── entity/          # エンティティ（JPA）
└── util/            # ユーティリティクラス
```

**設計の考え方:**

- **機能単位でのパッケージ分割**: 関連するクラスを同じパッケージにまとめ、結合度を高める
- **レイヤー単位での明確な分離**: web、service、dao、entityは厳密に分離
- **共通機能の集約**: common、utilパッケージで横断的な機能を集約

### 4.2 命名規約

命名は一貫性を持たせ、クラスの役割が名前から明確に理解できるようにする。

| コンポーネント種別 | 命名パターン | 例 |
|------------------|------------|-----|
| JSF Managed Bean | `{機能名}Bean` | `SearchBean`, `EntryBean` |
| JAX-RS Resource | `{リソース名}Resource` | `CustomerResource` |
| Service | `{エンティティ名}Service` | `CustomerService` |
| DAO | `{エンティティ名}Dao` | `CustomerDao` |
| Entity | `{エンティティ名}` | `Customer`, `Order` |
| DTO/TO | `{用途}TO` | `OrderTO`, `SearchResultTO` |
| Business Exception | `{業務エラー内容}Exception` | `DuplicateException` |

### 4.3 コンポーネント設計指針

#### 4.3.1 プレゼンテーション層（JSF Managed Bean）

**役割:**
- ユーザー入力の受付と画面項目の管理
- 画面遷移の制御
- Serviceへの処理委譲
- 画面表示用データの変換

**実装ガイド:**

```java
@Named
@ViewScoped  // または @SessionScoped, @RequestScoped
public class SomeBean implements Serializable {
    private static final Logger logger = LoggerFactory.getLogger(SomeBean.class);

    @Inject
    private SomeService service;

    private String inputParam;    // 画面入力項目
    private List<Entity> results; // 画面表示データ

    public String executeAction() {
        logger.info("[ SomeBean#executeAction ]");
        results = service.execute(inputParam);
        return "result?faces-redirect=true";
    }
}
```

**重要ポイント:**
- `@Named`でCDI管理Beanとして登録
- スコープは用途に応じて適切に選択（ViewScoped: 画面単位、SessionScoped: セッション全体、RequestScoped: リクエスト単位）
- SessionScoped/ViewScopedの場合は`Serializable`実装が必須
- アクションメソッドは遷移先を文字列で返す（`faces-redirect=true`でPOST-Redirect-GETを実現）
- ビジネスロジックはServiceに委譲し、Beanには記述しない

#### 4.3.2 プレゼンテーション層（JAX-RS Resource）

**役割:**
- REST APIのエンドポイント提供
- HTTPリクエスト/レスポンスの制御
- DTOとEntityの変換
- Serviceへの処理委譲

**実装ガイド:**

```java
@Path("/api/resources")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class SomeResource {
    @Inject
    private SomeService service;

    @GET
    @Path("/{id}")
    public Response getById(@PathParam("id") Integer id) {
        Entity entity = service.getById(id);
        return Response.ok(toTO(entity)).build();
    }
}
```

**重要ポイント:**
- クラスレベルで`@Path`、`@Produces`、`@Consumes`を定義
- メソッドレベルでHTTPメソッド（`@GET`、`@POST`、`@PUT`、`@DELETE`）を指定
- エンティティを直接公開せず、必ずDTO（TO）を介する
- `Response`オブジェクトでHTTPステータスコードを制御

#### 4.3.3 ビジネスロジック層（Service）

**役割:**
- ビジネスルールの実装
- トランザクション境界の定義
- 複数DAOの協調
- 業務検証の実施

**実装ガイド:**

```java
@ApplicationScoped
@Transactional
public class SomeService {
    private static final Logger logger = LoggerFactory.getLogger(SomeService.class);

    @Inject
    private SomeDao dao;

    public Entity execute(String param) {
        logger.info("[ SomeService#execute ]");
        
        // 業務検証
        validate(param);
        
        // データ操作
        Entity entity = dao.findById(param);
        // ビジネスロジック処理
        
        return entity;
    }
}
```

**重要ポイント:**
- `@ApplicationScoped`でシングルトン化（ステートレス設計）
- `@Transactional`でトランザクション境界を定義（クラスレベルまたはメソッドレベル）
- 全てのビジネスロジックをここに集約
- DAOへの依存は`@Inject`で注入
- 入力値の前処理や業務検証を実施

#### 4.3.4 データアクセス層（DAO）

**役割:**
- データベースのCRUD操作
- JPQLまたはCriteria APIによるクエリ実行
- エンティティのライフサイクル管理

**実装ガイド:**

```java
@ApplicationScoped
public class SomeDao {
    private static final Logger logger = LoggerFactory.getLogger(SomeDao.class);

    @PersistenceContext(unitName = "somePU")
    private EntityManager em;

    public Entity findById(Integer id) {
        logger.info("[ SomeDao#findById ]");
        return em.find(Entity.class, id);
    }

    public void persist(Entity entity) {
        em.persist(entity);
    }
}
```

**重要ポイント:**
- `@ApplicationScoped`でシングルトン化
- `@PersistenceContext`でEntityManagerを注入
- CRUD操作に専念し、ビジネスロジックは含めない
- 静的クエリはJPQL、動的クエリはCriteria APIを使用
- DAOメソッドはpublic、EntityManagerは直接使用せずDAOを介す

#### 4.3.5 データモデル層（Entity）

**役割:**
- データベーステーブルとのマッピング
- リレーションシップの定義
- データ構造の表現

**実装ガイド:**

```java
@Entity
@Table(name = "SOME_TABLE")
public class SomeEntity implements Serializable {
    @Id
    @Column(name = "ID")
    private Integer id;

    @Column(name = "NAME")
    private String name;

    @ManyToOne
    @JoinColumn(name = "PARENT_ID")
    private ParentEntity parent;

    // 引数なしコンストラクタ（JPA必須）
    public SomeEntity() {}
}
```

**重要ポイント:**
- `@Entity`でJPAエンティティとして定義
- `@Table`、`@Column`で物理名を明示的にマッピング
- リレーションシップは適切なアノテーション（`@ManyToOne`、`@OneToMany`等）で定義
- 引数なしコンストラクタは必須（JPAの要件）
- `Serializable`実装を推奨
- ビジネスロジックは含めず、データ構造の表現に専念

#### 4.3.6 データ転送オブジェクト（DTO/TO）

**役割:**
- REST APIの入出力データ構造
- レイヤー間のデータ転送
- エンティティの公開防止

**実装ガイド:**

```java
public record EntityTO(
    Integer id,
    String name,
    String description
) {}
```

**重要ポイント:**
- Java 17以降は`record`を使用（イミュータブル、簡潔）
- REST APIではエンティティを直接公開せず、必ずTOを介する
- センシティブ情報（パスワード等）は含めない
- JSON-Bによる自動シリアライズ・デシリアライズを活用

---

## 5. 認証・認可方式

### 5.1 JSFアプリケーションの認証

**方式: Servlet Filter + Session管理**

JSFアプリケーションでは、Servlet Filterで全リクエストをインターセプトし、SessionScopedのBeanでログイン状態を管理する方式を採用する。

**実装の考え方:**
1. `@WebFilter`で全XHTMLリクエストを捕捉
2. 公開ページリストを定義し、認証不要なページを除外
3. SessionScopedのLoginBeanでログイン状態を保持
4. 未ログイン時は強制的にログインページへリダイレクト
5. ログアウト時はセッション無効化（`invalidateSession()`）

**設計ポイント:**
- Filterは軽量に保ち、認証チェックのみを実施
- ログイン処理自体はServiceで実装
- パスワードはハッシュ化して保存（平文保存禁止）

### 5.2 REST APIの認証

REST APIはステートレスな設計を基本とし、以下のいずれかの方式を採用する。

| 方式 | 適用ケース | 実装方法 |
|------|----------|---------|
| JWT (JSON Web Token) | ステートレスなAPI認証 | JAX-RS `ContainerRequestFilter`でトークン検証 |
| OAuth 2.0 | 外部認証連携 | Jakarta Security / MicroProfile JWT |
| Basic認証 | 簡易的な認証 | `@RolesAllowed`アノテーション |

**実装の考え方:**
- JWTの場合、トークンにユーザー情報と有効期限を含める
- `ContainerRequestFilter`で全APIリクエストをインターセプト
- トークン検証失敗時は401 Unauthorizedを返す
- セッションは使用せず、ステートレス設計を維持

---

## 6. 入力チェック方式

### 6.1 Bean Validation（Jakarta Validation）

**適用場面:**
- エンティティのフィールド検証
- DTOのフィールド検証
- REST APIの入力検証

**実装の考え方:**

アノテーションベースで宣言的に検証ルールを定義する。

```java
@Entity
public class Customer {
    @NotNull(message = "名前は必須です")
    @Size(min = 1, max = 100)
    private String name;

    @Email(message = "有効なメールアドレスを入力してください")
    private String email;
}
```

**重要ポイント:**
- 形式的な検証（必須、桁数、形式）はBean Validationで実施
- メッセージはリソースファイル（ValidationMessages.properties）で管理
- JSFでは自動的に検証が実行される
- REST APIでは`@Valid`アノテーションで検証を有効化
- 検証エラーは`ConstraintViolationException`としてスロー

### 6.2 業務検証（ビジネスルール検証）

**適用場面:**
- データベースとの整合性チェック（重複チェック、存在チェック等）
- 複数項目の相関チェック
- 複雑なビジネスルールの検証

**実装の考え方:**

Bean Validationでは表現できない複雑な検証は、Serviceレイヤーで実施する。

```java
@ApplicationScoped
@Transactional
public class CustomerService {
    public Customer register(Customer customer) {
        // 業務検証：重複チェック
        if (dao.findByEmail(customer.getEmail()) != null) {
            throw new DuplicateException("メールアドレスが重複しています");
        }
        
        dao.persist(customer);
        return customer;
    }
}
```

**重要ポイント:**
- ビジネス例外をスローして検証エラーを表現
- 検証ロジックはServiceに集約
- 検証エラーはプレゼンテーション層で適切にハンドリング

---

## 7. 画面フロー方式（JSF）

### 7.1 ナビゲーション制御

**基本原則:**
- アクションメソッドは遷移先のビューIDを文字列で返す
- リダイレクトを使用してPOST-Redirect-GETパターンを実現
- 同じページに留まる場合は`null`を返す

**実装パターン:**

```java
// 成功時：リダイレクト遷移
public String execute() {
    service.execute();
    return "success?faces-redirect=true";
}

// エラー時：同じページに留まる
public String execute() {
    try {
        service.execute();
        return "success?faces-redirect=true";
    } catch (BusinessException e) {
        FacesContext.getCurrentInstance().addMessage(null,
            new FacesMessage(FacesMessage.SEVERITY_ERROR, "エラー", e.getMessage()));
        return null;
    }
}
```

**設計ポイント:**
- `faces-redirect=true`でリダイレクトを明示
- ブラウザのリロードによる二重送信を防止
- エラーメッセージは`FacesMessage`で画面に表示

### 7.2 スコープ管理

適切なスコープを選択することで、メモリ効率とユーザビリティを両立する。

| スコープ | 用途 | ライフサイクル | Serializable |
|---------|------|--------------|-------------|
| `@RequestScoped` | 単一リクエスト内のデータ | 1リクエスト | 不要 |
| `@ViewScoped` | 同一画面内のデータ（Ajax対応） | ページ遷移まで | **必須** |
| `@SessionScoped` | セッション全体でのデータ（ログイン情報等） | セッション終了まで | **必須** |
| `@ApplicationScoped` | アプリケーション全体での共有データ | アプリケーション停止まで | 不要 |

**選択基準:**
- 画面項目の一時保持 → `@ViewScoped`
- ログイン情報、カート → `@SessionScoped`
- 参照のみの検索処理 → `@RequestScoped`
- マスタデータキャッシュ → `@ApplicationScoped`

---

## 8. トランザクション方式

### 8.1 トランザクション管理

**基本方針:**
- 宣言的トランザクション（`@Transactional`）を使用
- トランザクション境界はServiceレイヤーで定義
- DAOレイヤーではトランザクション制御を行わない

**実装パターン:**

```java
@ApplicationScoped
@Transactional  // クラスレベル：全メソッドがトランザクション対象
public class SomeService {
    public void execute() {
        // メソッド開始〜終了がトランザクション境界
        // 例外発生時は自動ロールバック
    }
}
```

**トランザクション属性:**

| 属性 | 説明 | 用途 |
|------|------|------|
| `REQUIRED`（デフォルト） | 既存トランザクションに参加、なければ新規作成 | 通常の業務処理 |
| `REQUIRES_NEW` | 必ず新しいトランザクションを開始 | ログ記録等の独立処理 |
| `NOT_SUPPORTED` | トランザクション外で実行 | 参照のみの処理 |

**設計ポイント:**
- トランザクションは可能な限り短く保つ
- 長時間実行される処理はトランザクション分割を検討
- 読み取り専用の処理は`NOT_SUPPORTED`を検討

### 8.2 楽観的ロックと悲観的ロック

#### 8.2.1 楽観的ロック（推奨）

**適用場面:**
- 更新の競合が少ない場合
- 高い同時実行性が求められる場合

**実装方法:**

```java
@Entity
public class SomeEntity {
    @Version  // バージョン管理カラム
    private Long version;
}
```

**動作:**
- `@Version`アノテーションでバージョン管理カラムを指定
- 更新時に自動的にバージョンチェック
- バージョン不一致時は`OptimisticLockException`がスロー

**メリット:**
- データベースロックが不要で、高い同時実行性
- デッドロックのリスクが低い

#### 8.2.2 悲観的ロック

**適用場面:**
- 更新の競合が頻繁に発生する場合
- 確実にデータ整合性を保つ必要がある場合

**実装方法:**

```java
public SomeEntity findByIdWithLock(Integer id) {
    return em.find(SomeEntity.class, id, LockModeType.PESSIMISTIC_WRITE);
}
```

**動作:**
- `LockModeType.PESSIMISTIC_WRITE`でSELECT ... FOR UPDATEを実行
- トランザクション終了までレコードがロック
- 他のトランザクションはブロック

**デメリット:**
- 同時実行性が低下
- デッドロックのリスク

**使い分け:**
- 基本は楽観的ロックを使用
- 在庫管理等の厳密な排他制御が必要な場合のみ悲観的ロック

---

## 9. データベースアクセス方式

### 9.1 CRUD操作の標準パターン

**基本操作:**

```java
// Create（登録）
em.persist(entity);

// Read（検索）
Entity entity = em.find(Entity.class, id);

// Update（更新）
em.merge(entity);

// Delete（削除）
em.remove(entity);
```

**設計ポイント:**
- 全てのCRUD操作はDAOレイヤーで実施
- EntityManagerは直接使用せず、DAOを介する
- 検索条件が動的な場合はCriteria APIを使用

### 9.2 検索方式の使い分け

| 方式 | 適用場面 | 特徴 |
|------|---------|------|
| `em.find()` | 主キー検索 | 最もシンプル |
| JPQL | 静的な検索条件 | SQL類似で可読性が高い |
| Criteria API | 動的な検索条件 | 型安全、条件の動的構築が可能 |
| Native Query | 複雑なSQL | データベース依存、移植性低い |

**JPQL例:**

```java
TypedQuery<Entity> query = em.createQuery(
    "SELECT e FROM Entity e WHERE e.name = :name", Entity.class);
query.setParameter("name", name);
return query.getResultList();
```

**Criteria API例:**

```java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Entity> cq = cb.createQuery(Entity.class);
Root<Entity> root = cq.from(Entity.class);

List<Predicate> predicates = new ArrayList<>();
if (name != null) {
    predicates.add(cb.equal(root.get("name"), name));
}
cq.where(predicates.toArray(new Predicate[0]));

return em.createQuery(cq).getResultList();
```

### 9.3 パフォーマンス対策

#### 9.3.1 N+1問題の対策

**問題:**
関連エンティティのLazy Loadingにより、N+1回のSQLが実行される。

**対策:**
JOIN FETCHで一度に取得する。

```java
TypedQuery<Entity> query = em.createQuery(
    "SELECT e FROM Entity e LEFT JOIN FETCH e.relatedEntities", 
    Entity.class);
```

---

## 10. エラー・例外ハンドリング方式

### 10.1 例外設計方針

**例外の分類:**

| 例外種別 | 用途 | 継承元 | ログレベル |
|---------|------|--------|-----------|
| ビジネス例外 | 業務ルール違反（予期される） | `RuntimeException` | WARN |
| システム例外 | システム障害（予期しない） | `RuntimeException` | ERROR |
| 検証例外 | 入力値検証エラー | `ConstraintViolationException` | INFO |

**ビジネス例外の実装:**

```java
public class BusinessException extends RuntimeException {
    private String errorCode;
    
    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
}
```

**設計ポイント:**
- チェック例外は使用せず、全て`RuntimeException`を継承
- エラーコードを保持し、メッセージ管理を容易に
- 例外にビジネス情報（IDなど）を含めることも検討

### 10.2 例外ハンドリングパターン

#### 10.2.1 JSFでのハンドリング

```java
public String execute() {
    try {
        service.execute();
        return "success?faces-redirect=true";
    } catch (BusinessException e) {
        logger.warn("業務エラー: {}", e.getMessage());
        addErrorMessage(e.getMessage());
        return null;
    } catch (Exception e) {
        logger.error("システムエラー", e);
        addErrorMessage("予期しないエラーが発生しました");
        return null;
    }
}
```

#### 10.2.2 REST APIでのハンドリング

ExceptionMapperで集約的にハンドリングする。

```java
@Provider
public class BusinessExceptionMapper implements ExceptionMapper<BusinessException> {
    @Override
    public Response toResponse(BusinessException exception) {
        return Response.status(Response.Status.BAD_REQUEST)
                .entity(new ErrorResponse(exception.getErrorCode(), exception.getMessage()))
                .build();
    }
}
```

**HTTPステータスコードの使い分け:**

| ステータス | 用途 | 例外 |
|----------|------|------|
| 400 Bad Request | 入力値検証エラー | `ConstraintViolationException` |
| 401 Unauthorized | 認証エラー | `AuthenticationException` |
| 404 Not Found | リソース未存在 | `NotFoundException` |
| 409 Conflict | リソース重複 | `DuplicateException` |
| 500 Internal Server Error | システムエラー | `RuntimeException` |

---

## 11. ログ出力方式

### 11.1 ロギングフレームワーク

**標準: SLF4J + Logback**

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SomeClass {
    private static final Logger logger = LoggerFactory.getLogger(SomeClass.class);
}
```

**採用理由:**
- SLF4Jはファサードとして機能し、実装の切り替えが容易
- Logbackは高性能で設定が柔軟
- 業界標準として広く採用されている

### 11.2 ログレベルの使い分け

| レベル | 用途 | 出力内容 | 本番環境 |
|-------|------|---------|----------|
| ERROR | システムエラー | 例外スタックトレース、エラー内容 | 常時出力 |
| WARN | 業務例外、警告 | 業務エラー内容、リトライ等 | 常時出力 |
| INFO | 主要処理の記録 | メソッド開始、処理結果 | 常時出力 |
| DEBUG | 詳細な処理内容 | パラメータ値、中間結果 | 必要時のみ |
| TRACE | 非常に詳細な情報 | 全ての処理ステップ | 通常無効 |

### 11.3 ログ出力方針

#### 11.3.1 基本方針

1. **全publicメソッドの開始時にINFOログを出力**
2. **統一フォーマット**: `[ ClassName#methodName ]`
3. **重要なパラメータを記録**（個人情報を除く）
4. **例外は必ずログ出力**（スタックトレース含む）
5. **個人情報は出力しない**（パスワード、クレジットカード番号等）

#### 11.3.2 ログ出力パターン

**メソッド開始ログ:**

```java
public void execute() {
    logger.info("[ SomeService#execute ]");
}

public void execute(String param) {
    logger.info("[ SomeService#execute ] param={}", param);
}
```

**例外ログ:**

```java
// システム例外（ERROR）
try {
    execute();
} catch (Exception e) {
    logger.error("処理エラー", e);  // スタックトレースも出力
    throw new RuntimeException("処理に失敗しました", e);
}

// 業務例外（WARN）
if (exists) {
    logger.warn("重複エラー: key={}", key);
    throw new DuplicateException("すでに存在します");
}
```

---

## 12. 推奨技術スタック

| カテゴリ | 技術 | バージョン | 備考 |
|---------|------|----------|------|
| **基盤** | Jakarta EE | 10以上 | プラットフォーム標準 |
| **アプリケーションサーバー** | Payara Server | 6以上 | または WildFly, Open Liberty |
| **JDK** | Eclipse Temurin / Oracle JDK | 17以上 | Java 21推奨 |
| **依存性注入** | CDI (Jakarta CDI) | 4.0以上 | `@Inject`, `@ApplicationScoped` |
| **トランザクション** | JTA (Jakarta Transactions) | 2.0以上 | `@Transactional` |
| **永続化** | JPA (Jakarta Persistence) | 3.1以上 | EclipseLink実装 |
| **Webフレームワーク** | JSF (Jakarta Server Faces) | 4.0以上 | Facelets |
| **REST API** | JAX-RS | 3.1以上 | Jersey実装 |
| **JSON処理** | JSON-B | 3.0以上 | Yasson実装 |
| **バリデーション** | Jakarta Bean Validation | 3.0以上 | Hibernate Validator実装 |
| **ロギング** | SLF4J | 2.0以上 | Logback実装 |
| **ビルドツール** | Gradle | 8以上 | または Maven |

---

## 13. まとめ

### 13.1 重要原則

本ガイドラインを遵守することで、以下を実現する：

1. **レイヤーアーキテクチャの遵守**: 明確な責務分離により保守性を向上
2. **依存性注入の活用**: `@Inject`による疎結合設計で拡張性を確保
3. **宣言的トランザクション**: `@Transactional`で一貫したトランザクション管理
4. **適切な例外分類**: ビジネス例外とシステム例外を明確に区別
5. **ロギングの徹底**: トレーサビリティを確保し、問題解決を迅速化

### 13.2 品質向上のポイント

- **コードの一貫性**: 命名規約、パッケージ構成、処理パターンを統一
- **保守性**: 責務の分離、適切なコメント、ログ出力で保守を容易に
- **拡張性**: インターフェース分離、疎結合設計で将来の変更に対応
- **セキュリティ**: 認証・認可の実装、入力検証の徹底
- **パフォーマンス**: 適切なトランザクション境界、N+1問題の回避

本ガイドラインを遵守することで、チーム全体で統一された開発標準を維持し、高品質なシステムを構築できる。
