# アーキテクチャガイドライン

## 1. 目的と適用範囲

Jakarta EE 10を基盤としたWebアプリケーション開発における標準処理方式を定義し、プロジェクト間で一貫性のあるアーキテクチャを実現する。

**適用対象:**
- Jakarta EE 10以上を使用するWebアプリケーション
- JPA（Jakarta Persistence）を使用するデータベースアクセスを伴うシステム
- JSF（Jakarta Server Faces）またはJAX-RS（RESTful Web Services）を使用するプレゼンテーション層

---

## 2. レイヤーアーキテクチャ

### 2.1 4層構造

```
Presentation Layer (Managed Bean/Resource) → 入力受付・画面制御
     ↓ @Inject
Business Logic Layer (Service) → ビジネスルール・トランザクション境界
     ↓ @Inject
Data Access Layer (DAO) → CRUD操作・クエリ実行
     ↓ @PersistenceContext
Data Model Layer (Entity/DTO) → データ構造定義
```

### 2.2 原則

#### 依存関係の原則

- **単方向依存**: 上位層→下位層への単方向依存のみ許可
- **循環参照の禁止**: 下位層が上位層を参照することは厳禁
- **インターフェースの活用**: 必要に応じてServiceにインターフェースを定義し、実装を抽象化
- **依存性注入**: `@Inject`を使用し、newによる直接インスタンス化は避ける

#### 責務分離の原則

各レイヤーは明確な責務を持ち、他レイヤーの責務を侵害してはならない。

| レイヤー | 責務 | 禁止事項 |
|---------|------|----------|
| Presentation | 入力受付、画面遷移制御、表示用データ変換 | DB操作、ビジネスルール実装 |
| Business Logic | ビジネスルール実装、トランザクション境界定義、複数DAOの調整 | 直接的なDB操作、HTTPリクエスト/レスポンス処理 |
| Data Access | CRUD操作、クエリ実行、エンティティライフサイクル管理 | ビジネスルール実装、トランザクション制御 |
| Data Model | データ構造定義、リレーションシップ定義 | 処理ロジック（getter/setter以外のメソッド） |

#### レイヤー間のデータフロー

1. **リクエスト処理**: Presentation → Service → DAO → Entity
2. **レスポンス処理**: Entity → DAO → Service → DTO → Presentation
3. **例外処理**: 下位層で発生した例外を上位層で適切にハンドリング

---

## 3. コンポーネント設計

### 3.1 パッケージ構成

```
[root-package]/
├── common/          # 共通クラス（Enum、定数、共通例外）
├── web/             # Presentation層（JSF）
│   ├── [feature]/   # 機能別パッケージ（customer、order等）
│   └── filter/      # Servlet Filter
├── resource/        # Presentation層（REST API）
│   └── [feature]/   # 機能別パッケージ
├── service/         # Business Logic層
│   └── [feature]/   # 機能別パッケージ
│       ├── *Service.java
│       └── *ServiceIF.java（必要に応じて）
├── dao/             # Data Access層
├── entity/          # Entity（JPAエンティティ）
└── util/            # ユーティリティクラス
```

**設計の考え方:**

- **機能単位でのパッケージ分割**: 関連するクラスを同じパッケージにまとめ、結合度を高める
- **レイヤー単位での明確な分離**: web、resource、service、dao、entityは厳密に分離
- **共通機能の集約**: common、utilパッケージで横断的な機能を集約
- **パッケージ命名**: 機能名は小文字、複数単語の場合はキャメルケース（customerOrder等）

### 3.2 命名規約

命名は一貫性を持たせ、クラスの役割が名前から明確に理解できるようにする。

| 種別 | パターン | 例 | 備考 |
|------|---------|-----|------|
| JSF Bean | `{機能名}Bean` | `SearchBean`, `CustomerEntryBean` | 機能を表す名前 |
| JAX-RS Resource | `{リソース名}Resource` | `CustomerResource`, `OrderResource` | RESTリソース名 |
| Service | `{エンティティ名}Service` | `CustomerService`, `OrderService` | エンティティに対応 |
| Service Interface | `{エンティティ名}ServiceIF` | `CustomerServiceIF` | 必要な場合のみ |
| DAO | `{エンティティ名}Dao` | `CustomerDao`, `OrderDao` | エンティティに対応 |
| Entity | `{エンティティ名}` | `Customer`, `Order` | 単数形 |
| DTO | `{用途}TO` | `OrderTO`, `SearchResultTO` | Transfer Object |
| 業務例外 | `{内容}Exception` | `DuplicateException`, `InvalidStateException` | 具体的な内容 |
| システム例外 | `{内容}Exception` | `DataAccessException` | システム的な内容 |

**命名の一般原則:**

- **英語表記**: 日本語のローマ字表記は避ける
- **明確性**: 省略形は避け、完全な単語を使用（Mgr → Manager）
- **キャメルケース**: クラス名はアッパーキャメル、変数名はローワーキャメル
- **複数形**: コレクションを表す変数は複数形（customers、orders等）

### 3.3 各層の実装ポイント

#### Presentation層（JSF Managed Bean）
- `@Named`でCDI管理、`@ViewScoped`/`@SessionScoped`/`@RequestScoped`で適切なスコープ設定
- SessionScoped/ViewScopedは`Serializable`実装必須
- アクションメソッドは遷移先を返す（`faces-redirect=true`でPOST-Redirect-GET）
- ビジネスロジックはServiceに委譲

#### Presentation層（JAX-RS Resource）
- クラスレベルで`@Path`、`@Produces`、`@Consumes`定義
- Entityを直接公開せず、DTOを介する
- `Response`でHTTPステータスコード制御
- `@Valid`で入力検証、`ExceptionMapper`で集約的エラーハンドリング

#### Business Logic層（Service）
- `@ApplicationScoped`でシングルトン化（ステートレス設計）
- `@Transactional`でトランザクション境界定義
- ビジネスロジックと業務検証を実施
- 全publicメソッドの開始時にログ出力

#### Data Access層（DAO）
- `@ApplicationScoped`でシングルトン化
- `@PersistenceContext`でEntityManager注入
- CRUD操作に専念、ビジネスロジックは含めない
- 静的クエリ→JPQL、動的クエリ→Criteria API

#### Data Model層（Entity）
- `@Entity`で定義、`@Table`/`@Column`で物理名マッピング
- リレーションシップは`@ManyToOne`、`@OneToMany`等で定義
- 引数なしコンストラクタ必須、`Serializable`実装推奨

#### DTO/TO
- Java 17以降は`record`使用（イミュータブル）
- REST APIでEntityを直接公開せず、TOを介する
- センシティブ情報は含めない

---

## 4. 認証・認可

### 4.1 JSFアプリケーション
**方式**: Servlet Filter + Session管理

- `@WebFilter`で全XHTMLリクエストを捕捉、公開ページは除外
- SessionScopedのLoginBeanでログイン状態を保持
- 未ログイン時はログインページへリダイレクト
- パスワードはハッシュ化（BCrypt、PBKDF2等、平文保存禁止）
- セッションタイムアウト設定（推奨: 30分）、HTTPS通信強制

### 4.2 REST API
**方式**: ステートレス認証

| 方式 | 適用ケース | 実装方法 |
|------|----------|---------|
| JWT | ステートレスなAPI認証 | `ContainerRequestFilter`でトークン検証 |
| OAuth 2.0 | 外部認証連携 | Jakarta Security / MicroProfile JWT |
| Basic認証 | 簡易認証、内部API | `@RolesAllowed` |

### 4.3 認可（アクセス制御）
- `@RolesAllowed`アノテーションでメソッド単位のアクセス制御
- ロールはDB等で管理し、柔軟に変更可能にする
- 最小権限の原則に従う

---

## 5. 入力チェック

入力チェックは2段階で実施する：形式的な検証（Bean Validation）と業務検証（ビジネスルール検証）。

### 5.1 Bean Validation（形式検証）

**適用場面**: エンティティのフィールド検証、DTOのフィールド検証、REST APIの入力検証

**実装の考え方:**

アノテーションベースで宣言的に検証ルールを定義する。形式的な検証（必須、桁数、形式）はBean Validationで実施。

**主な検証アノテーション:**

| アノテーション | 用途 | 例 |
|-------------|------|-----|
| `@NotNull` | 必須チェック | IDフィールド |
| `@NotBlank` | 必須チェック（空文字不可） | 名前フィールド |
| `@Size(min, max)` | 文字列長チェック | `@Size(min=1, max=100)` |
| `@Min` / `@Max` | 数値範囲チェック | `@Min(0)` |
| `@Email` | メールアドレス形式チェック | メールフィールド |
| `@Pattern` | 正規表現チェック | 電話番号、郵便番号 |
| `@Past` / `@Future` | 日付チェック | 生年月日、予約日 |

**重要ポイント:**
- メッセージはリソースファイル（ValidationMessages.properties）で管理
- JSFでは自動的に検証が実行される
- REST APIでは`@Valid`アノテーションで検証を有効化
- 検証エラーは`ConstraintViolationException`としてスロー
- カスタムバリデータの作成も可能（複雑な形式検証）

### 5.2 業務検証（ビジネスルール検証）

**適用場面**: データベースとの整合性チェック、複数項目の相関チェック、複雑なビジネスルール

Bean Validationでは表現できない複雑な検証は、Serviceレイヤーで実施する。

**業務検証の種類:**
- **重複チェック**: メールアドレス、ユーザーID等の一意性確認
- **存在チェック**: 参照先データの存在確認
- **相関チェック**: 開始日≦終了日、在庫数≧注文数等
- **状態チェック**: 注文ステータスによる操作可否判定
- **権限チェック**: ユーザーの操作権限確認

**実装の考え方:**
- 検証ロジックはServiceレイヤーに集約
- ビジネス例外をスローして検証エラーを表現
- 例外にエラーコードとメッセージを含める
- Presentation層で適切にハンドリング（画面表示またはHTTPレスポンス）
- 検証の順序を考慮（形式検証→業務検証）

---

## 6. 画面フロー（JSF）

### 6.1 ナビゲーション制御

**基本原則:**
- アクションメソッドは遷移先のビューIDを文字列で返す
- リダイレクトを使用してPOST-Redirect-GETパターンを実現
- 同じページに留まる場合は`null`を返す

**実装パターン:**
- **成功時のリダイレクト遷移**: `return "success?faces-redirect=true";`
- **エラー時に同じページに留まる**: `return null;`
- **パラメータ付き遷移**: `return "detail?faces-redirect=true&id=" + id;`

**設計ポイント:**
- `faces-redirect=true`でリダイレクトを明示し、ブラウザのリロードによる二重送信を防止
- エラーメッセージは`FacesMessage`で画面に表示
- 処理成功時は必ずリダイレクトすることを推奨（ブックマーク対応、UX向上）

### 6.2 スコープ管理

適切なスコープを選択することで、メモリ効率とユーザビリティを両立する。

| スコープ | 用途 | ライフサイクル | Serializable | 使用例 |
|---------|------|--------------|-------------|--------|
| `@RequestScoped` | 単一リクエスト | 1リクエスト | 不要 | 参照のみの検索処理 |
| `@ViewScoped` | 同一画面（Ajax対応） | ページ遷移まで | **必須** | 画面項目の一時保持、Ajax処理 |
| `@SessionScoped` | セッション全体 | セッション終了まで | **必須** | ログイン情報、ショッピングカート |
| `@ApplicationScoped` | アプリケーション全体 | アプリ停止まで | 不要 | マスタデータキャッシュ |

**選択基準:**
- 画面内でデータを保持したい場合 → `@ViewScoped`
- セッション全体で共有したいデータ → `@SessionScoped`
- リクエスト単位で完結する処理 → `@RequestScoped`
- 全ユーザーで共有するデータ → `@ApplicationScoped`

**注意点:**
- ViewScopedとSessionScopedは必ず`Serializable`を実装
- SessionScopedの使用は最小限に（メモリ消費に注意）
- ApplicationScopedはスレッドセーフに実装

---

## 7. トランザクション

### 7.1 トランザクション管理

**基本方針:**
- 宣言的トランザクション（`@Transactional`）を使用
- トランザクション境界はServiceレイヤーで定義
- DAOレイヤーではトランザクション制御を行わない
- 例外発生時は自動ロールバック（RuntimeExceptionの場合）

**実装方法:**
- クラスレベルに`@Transactional`を付与：全メソッドがトランザクション対象
- メソッドレベルに`@Transactional`を付与：特定メソッドのみトランザクション対象
- トランザクションは可能な限り短く保つ（長時間ロックを避ける）

**トランザクション属性:**

| 属性 | 説明 | 用途 | 備考 |
|------|------|------|------|
| `REQUIRED`（デフォルト） | 既存に参加、なければ新規作成 | 通常の業務処理 | 最も一般的 |
| `REQUIRES_NEW` | 必ず新しいトランザクション開始 | ログ記録等の独立処理 | 既存トランザクションは中断 |
| `NOT_SUPPORTED` | トランザクション外で実行 | 参照のみの処理 | パフォーマンス向上 |
| `MANDATORY` | 既存トランザクション必須 | 内部メソッド | 単独呼び出しは例外 |
| `SUPPORTS` | トランザクションがあれば参加 | 柔軟な処理 | あまり使用しない |

**設計ポイント:**
- 読み取り専用の処理は`NOT_SUPPORTED`または`readOnly=true`を検討
- 長時間実行される処理はトランザクション分割を検討
- ネストしたトランザクションに注意（REQUIRES_NEWの使用）

### 7.2 ロック方式

#### 楽観的ロック（推奨）
- **適用**: 更新競合が少ない、高い同時実行性が必要な場合（Webアプリケーションの一般的なケース）
- **実装**: Entityに`@Version`アノテーションでバージョン管理
- **動作**: 更新時に自動バージョンチェック、不一致時は`OptimisticLockException`

#### 悲観的ロック
- **適用**: 更新競合が頻繁、厳密なデータ整合性が必要な場合（在庫管理、座席予約等）
- **実装**: `em.find()`の第3引数に`LockModeType.PESSIMISTIC_WRITE`
- **動作**: SELECT ... FOR UPDATEでトランザクション終了までレコードをロック

**使い分け**: 基本は楽観的ロック。在庫管理等の厳密な排他制御が必要な場合のみ悲観的ロック。

---

## 8. データベースアクセス

### 8.1 CRUD操作の標準パターン

**基本操作:**
- **Create（登録）**: `em.persist(entity)`
- **Read（検索）**: `em.find(Entity.class, id)`
- **Update（更新）**: `em.merge(entity)`
- **Delete（削除）**: `em.remove(entity)`

**設計ポイント:**
- 全てのCRUD操作はDAOレイヤーで実施
- EntityManagerは直接使用せず、必ずDAOを介する
- DAOメソッドは単一責任の原則に従い、シンプルに保つ

### 8.2 検索方式の使い分け

| 方式 | 適用場面 | 特徴 | 推奨度 |
|------|---------|------|--------|
| `em.find()` | 主キー検索 | 最もシンプル、1次キャッシュ利用 | ◎ |
| JPQL | 静的な検索条件 | SQL類似で可読性が高い、オブジェクト指向 | ◎ |
| Criteria API | 動的な検索条件 | 型安全、条件の動的構築が可能 | ○ |
| Native Query | 複雑なSQL、DB固有機能 | データベース依存、移植性低い | △ |

**使い分けの指針:**
- 主キーによる検索 → `em.find()`
- 固定的な検索条件 → JPQL（Named Queryとして定義推奨）
- 検索条件が動的に変わる → Criteria API
- データベース固有の機能が必要 → Native Query（最終手段）

### 8.3 パフォーマンス対策

**N+1問題の対策:**
- JOIN FETCHで関連エンティティを一括取得（一覧表示画面等）
- Entity Graphまたはバッチフェッチで取得戦略を定義

**その他の対策:**
- ページネーション: `setFirstResult()`、`setMaxResults()`で大量データをページング
- インデックス: 検索条件に使用するカラムにインデックス設定
- バルク操作: 大量データの更新・削除はバルク処理
- フェッチ戦略: デフォルトはLAZY、必要に応じてJOIN FETCHで明示的取得

---

## 9. エラー・例外ハンドリング

### 9.1 例外分類

| 例外種別 | 用途 | 継承元 | ログレベル |
|---------|------|--------|-----------|
| ビジネス例外 | 業務ルール違反 | `RuntimeException` | WARN |
| システム例外 | システム障害 | `RuntimeException` | ERROR |
| 検証例外 | 入力値検証エラー | `ConstraintViolationException` | INFO |

**設計ポイント:**
- チェック例外は使用せず、全て`RuntimeException`継承
- エラーコードを保持し、メッセージはプロパティファイルで管理
- 例外クラスは共通パッケージに集約

### 9.2 ハンドリング方法

#### JSF
- Beanでtry-catchを実施、ビジネス例外とシステム例外を分離
- エラーメッセージは`FacesMessage`で表示
- `return null;`で同じ画面に留まる

#### REST API
- `ExceptionMapper`で集約的にハンドリング
- HTTPステータスコードで例外種別を表現

| ステータス | 用途 | 例外 |
|----------|------|------|
| 400 Bad Request | 入力値検証エラー | `ConstraintViolationException` |
| 401 Unauthorized | 認証エラー | `AuthenticationException` |
| 403 Forbidden | 認可エラー | `AuthorizationException` |
| 404 Not Found | リソース未存在 | `NotFoundException` |
| 409 Conflict | リソース重複、状態不正 | `DuplicateException`, `InvalidStateException` |
| 500 Internal Server Error | システムエラー | `RuntimeException` |

---

## 10. ログ出力

### 10.1 ロギングフレームワーク
**標準**: SLF4J + Logback

### 10.2 ログレベル

| レベル | 用途 | 本番環境 |
|-------|------|----------|
| ERROR | システムエラー | 常時出力 |
| WARN | 業務例外、警告 | 常時出力 |
| INFO | 主要処理の記録 | 常時出力 |
| DEBUG | 詳細な処理内容 | 必要時のみ |
| TRACE | 非常に詳細な情報 | 通常無効 |

### 10.3 ログ出力方針

#### 基本方針

1. **全publicメソッドの開始時にINFOログを出力**
   - 処理の開始を明確に記録し、トラブルシューティングを容易に

2. **統一フォーマット**
   - メソッド開始: `[ ClassName#methodName ]`
   - パラメータ付き: `[ ClassName#methodName ] param1={}, param2={}`

3. **重要なパラメータを記録**
   - ビジネス的に重要な値（ID、キー情報等）を記録
   - 個人情報は出力しない（必要な場合はマスキング）

4. **例外は必ずログ出力**
   - システム例外: ERRORレベル、スタックトレース含む
   - 業務例外: WARNレベル、メッセージのみ

5. **個人情報の保護**
   - パスワード、クレジットカード番号、個人を特定できる情報は出力禁止

#### ログ設計のポイント

- **トレーサビリティ**: リクエストIDを使用し、一連の処理を追跡可能に
- **可読性**: ログメッセージは明確で具体的に記述
- **パフォーマンス**: SLF4Jのプレースホルダ（`{}`）を使用し、文字列連結を避ける
- **ローテーション**: 日次ローテーション、圧縮保存を設定

---

## 11. 推奨技術スタック

| カテゴリ | 技術 | バージョン | 備考 |
|---------|------|----------|------|
| 基盤 | Jakarta EE | 10以上 | プラットフォーム標準 |
| APサーバー | Payara Server | 6以上 | または WildFly 27以上、Open Liberty 23以上 |
| JDK | Eclipse Temurin / Oracle JDK | 17以上 | Java 21推奨（LTS） |
| 依存性注入 | CDI (Jakarta CDI) | 4.0以上 | `@Inject`, `@ApplicationScoped`等 |
| トランザクション | JTA (Jakarta Transactions) | 2.0以上 | `@Transactional` |
| 永続化 | JPA (Jakarta Persistence) | 3.1以上 | EclipseLink実装 |
| Web | JSF (Jakarta Server Faces) | 4.0以上 | Facelets、Ajax対応 |
| REST API | JAX-RS | 3.1以上 | Jersey実装 |
| JSON | JSON-B | 3.0以上 | Yasson実装、自動シリアライズ |
| バリデーション | Jakarta Bean Validation | 3.0以上 | Hibernate Validator実装 |
| ロギング | SLF4J + Logback | 2.0以上 | ファサードパターン |
| ビルド | Gradle / Maven | 8以上 / 3.9以上 | 依存関係管理 |

---

## 12. まとめ

本ガイドラインの遵守により以下を実現：

1. **レイヤーアーキテクチャの遵守** - 明確な責務分離で保守性向上
2. **依存性注入の活用** - 疎結合設計で拡張性確保
3. **宣言的トランザクション** - 一貫したトランザクション管理
4. **適切な例外分類** - ビジネス例外とシステム例外の明確な区別
5. **ロギングの徹底** - トレーサビリティ確保と迅速な問題解決

**品質向上のポイント**: コード一貫性、保守性、拡張性、セキュリティ、パフォーマンス
