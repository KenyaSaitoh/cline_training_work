# アーキテクチャガイドライン

## 1. 目的

本書は、Jakarta EE 10を基盤としたWebアプリケーション開発における標準的な処理方式を定義し、プロジェクト間で一貫性のあるアーキテクチャを実現することを目的とする。

## 2. 適用範囲

- Jakarta EE 10以上を使用するWebアプリケーション
- JPA（Jakarta Persistence）を使用するデータベースアクセスを伴うシステム
- JSF（Jakarta Server Faces）またはJAX-RS（RESTful Web Services）を使用するプレゼンテーション層

## 3. アーキテクチャ基本方針

### 3.1 レイヤーアーキテクチャ

システムは以下の4層構造を基本とする。

```
┌─────────────────────────────────────┐
│  プレゼンテーション層                │  ← JSF Managed Bean / JAX-RS Resource
│  (Presentation Layer)                │     ユーザーインタフェース・API制御
└─────────────────────────────────────┘
           ↓ 依存（@Inject）
┌─────────────────────────────────────┐
│  ビジネスロジック層                   │  ← Service
│  (Business Logic Layer)              │     業務ロジック・トランザクション境界
└─────────────────────────────────────┘
           ↓ 依存（@Inject）
┌─────────────────────────────────────┐
│  データアクセス層                     │  ← DAO (Data Access Object)
│  (Data Access Layer)                 │     CRUD操作・クエリ実行
└─────────────────────────────────────┘
           ↓ 依存（@PersistenceContext）
┌─────────────────────────────────────┐
│  データモデル層                       │  ← Entity / DTO
│  (Data Model Layer)                  │     データ構造定義
└─────────────────────────────────────┘
```

### 3.2 依存関係の原則

- **上位層から下位層への単方向依存**：下位層は上位層を参照してはならない
- **同一レイヤー内での依存は最小化**：必要に応じて別サービスへの依存は許容されるが、循環参照は禁止
- **インターフェース分離**：必要に応じてServiceにインターフェースを定義し、実装を抽象化する

### 3.3 責務の分離

| レイヤー | 責務 | 禁止事項 |
|---------|------|----------|
| Presentation | 入力受付、画面遷移制御、表示用データ変換 | 直接的なDB操作、ビジネスルール実装 |
| Business Logic | ビジネスルール実装、トランザクション境界定義、複数DAOの調整 | 直接的なDB操作、HTTPリクエスト処理 |
| Data Access | CRUD操作、クエリ実行、エンティティ管理 | ビジネスルール実装、トランザクション制御 |
| Data Model | データ構造定義、リレーションシップ定義 | 処理ロジック（計算・検証はプロパティレベルに留める） |

---

## 4. コンポーネント分割方式

### 4.1 パッケージ構成標準

```
[root-package]/
├── config/          # アプリケーション設定クラス（JAX-RS Configなど）
├── web/             # プレゼンテーション層（JSF用）
│   ├── [feature]/   # 機能別パッケージ（book, cart, order, loginなど）
│   │   └── *Bean.java
│   └── filter/      # Servlet Filter
├── resource/        # プレゼンテーション層（REST API用）
│   └── *Resource.java
│   └── *ExceptionMapper.java
├── service/         # ビジネスロジック層
│   └── [feature]/   # 機能別パッケージ
│       └── *Service.java
│       └── *ServiceIF.java (必要に応じて)
│       └── *Exception.java (ビジネス例外)
│       └── *TO.java (Transfer Object、必要に応じて)
├── dao/             # データアクセス層
│   └── *Dao.java
├── entity/          # エンティティ（JPA）
│   └── *.java
├── dto/             # データ転送オブジェクト（REST API用）
│   └── *TO.java
└── exception/       # 共通例外クラス
    └── *Exception.java
```

### 4.2 命名規約

| コンポーネント種別 | 命名パターン | 例 |
|------------------|------------|-----|
| JSF Managed Bean | `{機能名}Bean` | `BookSearchBean`, `CartBean` |
| JAX-RS Resource | `{リソース名}Resource` | `CustomerResource` |
| Service | `{エンティティ名}Service` | `BookService`, `OrderService` |
| DAO | `{エンティティ名}Dao` | `BookDao`, `CustomerDao` |
| Entity | `{エンティティ名}` | `Book`, `Customer`, `OrderTran` |
| DTO/TO | `{エンティティ名}TO` | `CustomerTO`, `OrderHistoryTO` |
| Business Exception | `{業務エラー内容}Exception` | `OutOfStockException`, `CustomerNotFoundException` |

### 4.3 クラス設計原則

#### 4.3.1 プレゼンテーション層（JSF Managed Bean）

```java
@Named
@ViewScoped  // または @SessionScoped
public class BookSearchBean implements Serializable {
    private static final long serialVersionUID = 1L;
    private static final Logger logger = LoggerFactory.getLogger(BookSearchBean.class);

    @Inject
    private BookService bookService;  // Serviceへの依存性注入

    // 画面項目（入力・出力）
    private Integer categoryId;
    private List<Book> bookList;

    @PostConstruct
    public void init() {
        // 初期化処理
    }

    // アクションメソッド：ナビゲーション制御
    public String search() {
        bookList = bookService.searchBook(categoryId);
        return "result?faces-redirect=true";
    }

    // Getter/Setter
}
```

**設計ポイント：**
- `@Named`でCDI Beanとして登録
- スコープアノテーション（`@ViewScoped`, `@SessionScoped`, `@RequestScoped`）で適切なライフサイクルを指定
- `Serializable`実装（SessionScoped/ViewScopedの場合は必須）
- ロガーは`static final`で定義
- アクションメソッドは画面遷移先を返す（`faces-redirect=true`推奨）

#### 4.3.2 プレゼンテーション層（JAX-RS Resource）

```java
@Path("/customers")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class CustomerResource {
    private static final Logger logger = LoggerFactory.getLogger(CustomerResource.class);

    @Inject
    private CustomerService customerService;

    @GET
    @Path("/{customerId}")
    public Response getById(@PathParam("customerId") Integer customerId) {
        logger.info("[ CustomerResource#getById ]");
        
        Customer customer = customerService.getCustomerById(customerId);
        CustomerTO response = toCustomerTO(customer);
        
        return Response.ok(response).build();
    }

    @POST
    @Path("/")
    public Response create(CustomerTO request) {
        Customer customer = toCustomer(request);
        customerService.registerCustomer(customer);
        return Response.ok(toCustomerTO(customer)).build();
    }

    // Entity ⇔ DTO 変換メソッド
    private CustomerTO toCustomerTO(Customer customer) { /*...*/ }
    private Customer toCustomer(CustomerTO dto) { /*...*/ }
}
```

**設計ポイント：**
- クラスレベルで`@Path`, `@Produces`, `@Consumes`を定義
- メソッドレベルでHTTPメソッド（`@GET`, `@POST`, `@PUT`, `@DELETE`）を指定
- エンティティを直接公開せず、DTO（TO）を介して情報を送受信
- `Response`オブジェクトを返してHTTPステータスを制御

#### 4.3.3 ビジネスロジック層（Service）

```java
@ApplicationScoped
@Transactional
public class BookService {
    private static final Logger logger = LoggerFactory.getLogger(BookService.class);

    @Inject
    private BookDao bookDao;

    // ビジネスロジックメソッド
    public Book getBook(Integer bookId) {
        logger.info("[ BookService#getBook ]");
        
        Book book = bookDao.findById(bookId);
        if (book == null) {
            throw new RuntimeException("Book not found: " + bookId);
        }
        return book;
    }

    public List<Book> searchBook(Integer categoryId, String keyword) {
        logger.info("[ BookService#searchBook ]");
        return bookDao.query(categoryId, toLikeWord(keyword));
    }

    private String toLikeWord(String keyword) {
        return "%" + keyword + "%";
    }
}
```

**設計ポイント：**
- `@ApplicationScoped`でシングルトン化（ステートレスなサービス）
- `@Transactional`でトランザクション境界を定義（クラスレベルまたはメソッドレベル）
- ビジネスルールの実装、複数DAOの調整を担当
- 入力値の前処理（検索キーワード整形など）や業務検証を実施

#### 4.3.4 データアクセス層（DAO）

```java
@ApplicationScoped
public class BookDao {
    private static final Logger logger = LoggerFactory.getLogger(BookDao.class);

    @PersistenceContext(unitName = "bookstorePU")
    private EntityManager em;

    // 主キー検索
    public Book findById(Integer bookId) {
        logger.info("[ BookDao#findById ]");
        return em.find(Book.class, bookId);
    }

    // JPQL検索
    public List<Book> findAll() {
        logger.info("[ BookDao#findAll ]");
        TypedQuery<Book> query = em.createQuery(
            "SELECT b FROM Book b", Book.class);
        return query.getResultList();
    }

    // 条件検索（Criteria API）
    public List<Book> searchWithCriteria(Integer categoryId, String keyword) {
        logger.info("[ BookDao#searchWithCriteria ]");
        
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<Book> cq = cb.createQuery(Book.class);
        Root<Book> book = cq.from(Book.class);

        List<Predicate> predicates = new ArrayList<>();
        
        if (categoryId != null) {
            predicates.add(cb.equal(book.get("category").get("categoryId"), categoryId));
        }
        
        if (keyword != null && !keyword.isEmpty()) {
            predicates.add(cb.like(book.get("bookName"), keyword));
        }

        if (!predicates.isEmpty()) {
            cq.where(predicates.toArray(new Predicate[0]));
        }

        return em.createQuery(cq).getResultList();
    }

    // 登録
    public void persist(Book book) {
        em.persist(book);
    }

    // 更新
    public Book merge(Book book) {
        return em.merge(book);
    }

    // 削除
    public void remove(Book book) {
        em.remove(book);
    }
}
```

**設計ポイント：**
- `@ApplicationScoped`でシングルトン化
- `@PersistenceContext`で`EntityManager`を注入
- CRUD操作、JPQL、Criteria APIを使い分ける
- ビジネスロジックは含まない（純粋なデータアクセスに専念）

#### 4.3.5 データモデル層（Entity）

```java
@Entity
@Table(name = "BOOK")
public class Book implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @Column(name = "BOOK_ID")
    private Integer bookId;

    @Column(name = "BOOK_NAME")
    private String bookName;

    @ManyToOne(targetEntity = Category.class)
    @JoinColumn(name = "CATEGORY_ID", referencedColumnName = "CATEGORY_ID")
    private Category category;

    @Column(name = "PRICE")
    private BigDecimal price;

    // 引数なしコンストラクタ（JPA必須）
    public Book() {}

    // 全フィールドコンストラクタ
    public Book(Integer bookId, String bookName, /*...*/) {
        this.bookId = bookId;
        this.bookName = bookName;
        // ...
    }

    // Getter/Setter
}
```

**設計ポイント：**
- `@Entity`でJPAエンティティとして定義
- `@Table`, `@Column`でテーブル・カラムをマッピング
- リレーションシップは`@ManyToOne`, `@OneToMany`等で定義
- 引数なしコンストラクタ必須（JPAの要件）
- `Serializable`実装推奨

#### 4.3.6 データ転送オブジェクト（DTO/TO）

```java
public record CustomerTO(
    Integer customerId,
    String customerName,
    String email,
    LocalDate birthday,
    String address
) {}
```

**設計ポイント：**
- Java 17以降は`record`を使用（イミュータブル、簡潔）
- REST APIの入出力で使用（エンティティを直接公開しない）
- センシティブ情報（パスワードなど）は含めない
- JSON-Bによる自動シリアライズ・デシリアライズ

---

## 5. 認証・認可方式

### 5.1 認証方式

#### 5.1.1 JSFアプリケーションの認証

**方式：Servlet Filter + Session管理**

```java
@WebFilter(filterName = "AuthenticationFilter", urlPatterns = {"*.xhtml"})
public class AuthenticationFilter implements Filter {
    private static final Logger logger = LoggerFactory.getLogger(AuthenticationFilter.class);

    @Inject
    private LoginBean loginBean;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                         FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        String requestURI = httpRequest.getRequestURI();
        String contextPath = httpRequest.getContextPath();
        
        // 認証不要なページ（公開ページ）のリスト
        boolean isPublicPage = requestURI.endsWith("/index.xhtml") 
                || requestURI.endsWith("/register.xhtml")
                || requestURI.contains("/jakarta.faces.resource/");
        
        // ログイン状態をチェック
        boolean isLoggedIn = (loginBean != null && loginBean.isLoggedIn());
        
        // 未ログインで保護されたページにアクセスした場合、リダイレクト
        if (!isPublicPage && !isLoggedIn) {
            logger.info("未ログインユーザーをリダイレクト: {}", requestURI);
            httpResponse.sendRedirect(contextPath + "/index.xhtml");
        } else {
            chain.doFilter(request, response);
        }
    }
}
```

**ログインBean：**

```java
@Named
@SessionScoped
public class LoginBean implements Serializable {
    private static final Logger logger = LoggerFactory.getLogger(LoginBean.class);

    @Inject
    private CustomerService customerService;

    private String email;
    private String password;
    private boolean loggedIn = false;

    public String processLogin() {
        logger.info("[ LoginBean#processLogin ] email={}", email);

        try {
            Customer customer = customerService.authenticate(email, password);
            
            if (customer == null) {
                FacesContext.getCurrentInstance().addMessage(null,
                    new FacesMessage(FacesMessage.SEVERITY_ERROR,
                        "ログインに失敗しました",
                        "メールアドレスまたはパスワードが正しくありません"));
                return null;
            }

            loggedIn = true;
            return "home?faces-redirect=true";

        } catch (Exception e) {
            logger.error("Login error", e);
            return null;
        }
    }

    public String processLogout() {
        FacesContext.getCurrentInstance().getExternalContext().invalidateSession();
        return "index?faces-redirect=true";
    }

    public boolean isLoggedIn() {
        return loggedIn;
    }
}
```

**設計ポイント：**
- Servlet Filterで全リクエストをインターセプト
- `@SessionScoped`のLoginBeanでログイン状態を管理
- 公開ページリストをFilterで定義
- ログアウト時はセッション無効化（`invalidateSession()`）

#### 5.1.2 REST APIの認証（今後の拡張指針）

REST APIでは、以下のいずれかの方式を採用する：

| 方式 | 適用ケース | 実装方法 |
|------|----------|---------|
| JWT (JSON Web Token) | ステートレスなAPI認証 | JAX-RS `ContainerRequestFilter`でトークン検証 |
| OAuth 2.0 | 外部認証連携 | Jakarta Security / MicroProfile JWT |
| Basic認証 | 簡易的な認証 | `@RolesAllowed`アノテーション |

### 5.2 認可方式

#### 5.2.1 ロールベースアクセス制御（RBAC）

```java
@DeclareRoles({"user", "admin"})
@WebServlet("/admin/*")
@ServletSecurity(
    @HttpConstraint(rolesAllowed = {"admin"})
)
public class AdminServlet extends HttpServlet {
    // 管理者のみアクセス可能
}
```

#### 5.2.2 メソッドレベルセキュリティ

```java
@ApplicationScoped
public class OrderService {
    
    @RolesAllowed("user")
    public void createOrder(OrderTO order) {
        // 一般ユーザーも実行可能
    }

    @RolesAllowed("admin")
    public void cancelOrder(Integer orderId) {
        // 管理者のみ実行可能
    }
}
```

---

## 6. 入力チェック方式

### 6.1 Bean Validation（Jakarta Validation）

#### 6.1.1 エンティティでの検証定義

```java
@Entity
public class Customer {
    
    @NotNull(message = "顧客名は必須です")
    @Size(min = 1, max = 100, message = "顧客名は1〜100文字で入力してください")
    private String customerName;

    @NotNull(message = "メールアドレスは必須です")
    @Email(message = "有効なメールアドレスを入力してください")
    private String email;

    @Past(message = "誕生日は過去の日付を指定してください")
    private LocalDate birthday;

    // ...
}
```

#### 6.1.2 JSFでの検証

```xml
<h:inputText id="email" value="#{customerBean.email}" 
             required="true" requiredMessage="メールアドレスは必須です"
             validatorMessage="有効なメールアドレスを入力してください">
    <f:validateRegex pattern=".+@.+\..+" />
</h:inputText>
<h:message for="email" styleClass="error" />
```

#### 6.1.3 REST APIでの検証

```java
@Path("/customers")
public class CustomerResource {

    @POST
    @Path("/")
    public Response create(@Valid CustomerTO request) {
        // @Validアノテーションにより自動検証
        // 検証エラーは400 Bad Requestとして返される
        customerService.registerCustomer(toCustomer(request));
        return Response.ok().build();
    }
}
```

**DTOでの検証定義：**

```java
public record CustomerTO(
    Integer customerId,
    
    @NotNull(message = "顧客名は必須です")
    @Size(min = 1, max = 100)
    String customerName,
    
    @NotNull
    @Email
    String email,
    
    @Past
    LocalDate birthday,
    
    String address
) {}
```

### 6.2 業務検証（ビジネスルール検証）

業務ロジック層（Service）またはプレゼンテーション層（Managed Bean）で実施する。

#### 6.2.1 Service層での業務検証

```java
@ApplicationScoped
@Transactional
public class CustomerService {

    public Customer registerCustomer(Customer customer) {
        // 業務検証：メールアドレスの重複チェック
        Customer existing = customerDao.findCustomerByEmail(customer.getEmail());
        if (existing != null) {
            throw new CustomerExistsException("指定されたメールアドレスはすでに存在します");
        }

        customerDao.persist(customer);
        return customer;
    }
}
```

#### 6.2.2 Managed Bean層での業務検証（住所検証）

**AddressUtilを使用した都道府県チェック:**

```java
@Named
@ViewScoped
public class CustomerBean implements Serializable {
    
    @Inject
    private CustomerService customerService;
    
    private String address;
    
    public String register() {
        // 住所の都道府県チェック（手動バリデーション）
        if (!AddressUtil.startsWithValidPrefecture(address)) {
            FacesContext.getCurrentInstance().addMessage(null,
                new FacesMessage(FacesMessage.SEVERITY_ERROR, 
                    "住所エラー", 
                    "都道府県名が正しく入力されていません"));
            return null;  // 同じページに留まる
        }
        
        // 顧客登録処理
        Customer customer = new Customer(/*...*/);
        customer.setAddress(address);
        customerService.registerCustomer(customer);
        
        return "success?faces-redirect=true";
    }
}
```

**設計ポイント:**
- Bean Validationでカバーできない複雑な業務ルール（重複チェック、複数項目の相関チェックなど）は手動検証
- 都道府県チェックのような、データベースに依存しない純粋なフォーマット検証は、共通ユーティリティ（AddressUtil）に集約
- 検証失敗時は`FacesMessage`でユーザーにエラー内容を明示

### 6.3 検証エラーのハンドリング

#### 6.3.1 JSFでのエラー表示

```xml
<!-- グローバルメッセージ -->
<h:messages globalOnly="true" styleClass="error" />

<!-- フィールド個別メッセージ -->
<h:inputText id="email" value="#{bean.email}" />
<h:message for="email" styleClass="error" />
```

#### 6.3.2 REST APIでのエラーレスポンス

```java
@Provider
public class ValidationExceptionMapper implements ExceptionMapper<ConstraintViolationException> {

    @Override
    public Response toResponse(ConstraintViolationException exception) {
        List<String> errors = exception.getConstraintViolations().stream()
            .map(ConstraintViolation::getMessage)
            .collect(Collectors.toList());
        
        ErrorResponse errorResponse = new ErrorResponse("validation.error", errors);
        return Response.status(Response.Status.BAD_REQUEST)
                .entity(errorResponse)
                .build();
    }
}
```

---

## 7. 画面フロー方式（JSF）

### 7.1 ナビゲーション制御

#### 7.1.1 暗黙的ナビゲーション

```java
public String search() {
    bookList = bookService.searchBook(keyword);
    // "result.xhtml"へ遷移
    return "result";
}
```

#### 7.1.2 リダイレクト遷移（推奨）

```java
public String search() {
    bookList = bookService.searchBook(keyword);
    // リダイレクトでPOST-Redirect-GETパターンを実現
    return "result?faces-redirect=true";
}
```

#### 7.1.3 条件分岐ナビゲーション

```java
public String processOrder() {
    try {
        orderService.createOrder(order);
        return "orderComplete?faces-redirect=true";
    } catch (OutOfStockException e) {
        FacesContext.getCurrentInstance().addMessage(null,
            new FacesMessage(FacesMessage.SEVERITY_ERROR, "在庫不足", e.getMessage()));
        return null;  // 同じページに留まる
    }
}
```

### 7.2 スコープ管理

| スコープ | 用途 | ライフサイクル | Serializable |
|---------|------|--------------|-------------|
| `@RequestScoped` | 単一リクエスト内のデータ保持 | 1リクエスト | 不要 |
| `@ViewScoped` | 同一画面内のデータ保持（Ajax対応） | ページ遷移まで | **必須** |
| `@SessionScoped` | セッション全体でのデータ保持（ログイン情報、カートなど） | セッション終了まで | **必須** |
| `@ApplicationScoped` | アプリケーション全体での共有データ | アプリケーション停止まで | 不要 |

### 7.3 POST-Redirect-GETパターン

```java
// POSTリクエスト処理後、リダイレクトでGETリクエストに変換
public String create() {
    customerService.registerCustomer(customer);
    // ブラウザの再読み込みによる二重送信を防止
    return "complete?faces-redirect=true";
}
```

---

## 8. ビジネスロジック・トランザクション方式

### 8.1 トランザクション管理

#### 8.1.1 宣言的トランザクション（推奨）

```java
@ApplicationScoped
@Transactional  // クラスレベル：全メソッドがトランザクション対象
public class OrderService {

    public void createOrder(OrderTO order) {
        // トランザクション境界：メソッド開始〜終了
        // 例外発生時は自動ロールバック
    }
}
```

#### 8.1.2 メソッドレベルのトランザクション制御

```java
@ApplicationScoped
public class OrderService {

    @Transactional  // メソッドレベル
    public void createOrder(OrderTO order) {
        // このメソッドのみトランザクション対象
    }

    // トランザクション対象外（参照のみの場合など）
    public List<Order> getOrderHistory(Integer customerId) {
        return orderDao.findByCustomerId(customerId);
    }
}
```

#### 8.1.3 トランザクション属性

```java
@Transactional(Transactional.TxType.REQUIRED)  // デフォルト：既存トランザクションに参加
public void method1() {}

@Transactional(Transactional.TxType.REQUIRES_NEW)  // 新しいトランザクションを開始
public void method2() {}

@Transactional(Transactional.TxType.NOT_SUPPORTED)  // トランザクション外で実行
public void method3() {}
```

### 8.2 楽観的ロックと悲観的ロック

#### 8.2.1 楽観的ロック（Optimistic Locking）

```java
@Entity
public class Stock {
    
    @Id
    private Integer bookId;

    private Integer quantity;

    @Version  // バージョン管理カラム
    private Integer version;

    // ...
}
```

```java
// 更新時に自動的にバージョンチェック
public void updateStock(Integer bookId, Integer newQuantity) {
    Stock stock = stockDao.findById(bookId);
    stock.setQuantity(newQuantity);
    stockDao.merge(stock);  // バージョン不一致時はOptimisticLockExceptionがスロー
}
```

#### 8.2.2 悲観的ロック（Pessimistic Locking）

```java
@ApplicationScoped
public class StockDao {

    @PersistenceContext
    private EntityManager em;

    public Stock findByIdWithLock(Integer bookId) {
        // SELECT ... FOR UPDATE
        return em.find(Stock.class, bookId, LockModeType.PESSIMISTIC_WRITE);
    }
}
```

```java
@Transactional
public void orderBooks(OrderTO order) {
    for (CartItem item : order.cartItems()) {
        // 悲観的ロックで在庫を取得（他トランザクションはブロック）
        Stock stock = stockDao.findByIdWithLock(item.getBookId());

        int remaining = stock.getQuantity() - item.getCount();
        if (remaining < 0) {
            throw new OutOfStockException(item.getBookId(), item.getBookName(), "在庫不足");
        }

        stock.setQuantity(remaining);
    }

    // 注文登録処理
    // ...
}
```

### 8.3 複数エンティティの操作

```java
@ApplicationScoped
@Transactional
public class OrderService {

    @Inject
    private OrderTranDao orderTranDao;

    @Inject
    private OrderDetailDao orderDetailDao;

    @Inject
    private StockDao stockDao;

    public OrderTran createOrder(OrderTO orderTO) {
        // 1. 在庫チェック・更新（複数テーブル操作）
        for (CartItem item : orderTO.cartItems()) {
            Stock stock = stockDao.findByIdWithLock(item.getBookId());
            stock.setQuantity(stock.getQuantity() - item.getCount());
        }

        // 2. 注文ヘッダー登録
        OrderTran orderTran = new OrderTran(/*...*/);
        orderTranDao.persist(orderTran);

        // 3. 注文明細登録
        int detailId = 0;
        for (CartItem item : orderTO.cartItems()) {
            detailId++;
            OrderDetail detail = new OrderDetail(
                orderTran.getOrderTranId(), detailId, /*...*/);
            orderDetailDao.persist(detail);
        }

        // 全て成功またはロールバック（トランザクション境界）
        return orderTran;
    }
}
```

---

## 9. データベースアクセス方式

### 9.1 JPA（Jakarta Persistence）の使用

#### 9.1.1 EntityManagerの注入

```java
@ApplicationScoped
public class BookDao {

    @PersistenceContext(unitName = "bookstorePU")
    private EntityManager em;

    // ...
}
```

**persistence.xml設定例：**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="3.0"
    xmlns="https://jakarta.ee/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://jakarta.ee/xml/ns/persistence
                        https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd">
    
    <persistence-unit name="bookstorePU" transaction-type="JTA">
        <jta-data-source>jdbc/HsqldbDS</jta-data-source>
        
        <properties>
            <property name="eclipselink.target-database" 
                      value="org.eclipse.persistence.platform.database.HSQLPlatform"/>
            <property name="eclipselink.logging.level" value="FINE"/>
        </properties>
    </persistence-unit>
</persistence>
```

### 9.2 CRUD操作の標準実装

#### 9.2.1 Create（登録）

```java
public void persist(Book book) {
    em.persist(book);
}
```

#### 9.2.2 Read（検索）

```java
// 主キー検索
public Book findById(Integer bookId) {
    return em.find(Book.class, bookId);
}

// JPQL
public List<Book> findAll() {
    TypedQuery<Book> query = em.createQuery(
        "SELECT b FROM Book b", Book.class);
    return query.getResultList();
}

// Named Parameter
public List<Book> findByCategory(Integer categoryId) {
    TypedQuery<Book> query = em.createQuery(
        "SELECT b FROM Book b WHERE b.category.categoryId = :categoryId", 
        Book.class);
    query.setParameter("categoryId", categoryId);
    return query.getResultList();
}
```

#### 9.2.3 Update（更新）

```java
public Book merge(Book book) {
    return em.merge(book);
}
```

#### 9.2.4 Delete（削除）

```java
public void remove(Book book) {
    em.remove(book);
}

// Detachedエンティティの削除
public void removeById(Integer bookId) {
    Book book = em.find(Book.class, bookId);
    if (book != null) {
        em.remove(book);
    }
}
```

### 9.3 Criteria API（動的クエリ）

```java
public List<Book> searchWithCriteria(Integer categoryId, String keyword) {
    CriteriaBuilder cb = em.getCriteriaBuilder();
    CriteriaQuery<Book> cq = cb.createQuery(Book.class);
    Root<Book> book = cq.from(Book.class);

    // 動的に条件を構築
    List<Predicate> predicates = new ArrayList<>();
    
    if (categoryId != null) {
        predicates.add(cb.equal(
            book.get("category").get("categoryId"), categoryId));
    }
    
    if (keyword != null && !keyword.isEmpty()) {
        predicates.add(cb.like(book.get("bookName"), keyword));
    }

    // 条件が存在する場合のみWHERE句を追加
    if (!predicates.isEmpty()) {
        cq.where(predicates.toArray(new Predicate[0]));
    }

    return em.createQuery(cq).getResultList();
}
```

**Criteria API使用指針：**
- 検索条件が動的に変化する場合に使用
- 静的な検索条件の場合はJPQLを優先（可読性）

### 9.4 JOIN FETCH（N+1問題対策）

```java
// Lazy Loadingの際のN+1問題を回避
public List<OrderTran> findByCustomerIdWithDetails(Integer customerId) {
    TypedQuery<OrderTran> query = em.createQuery(
        "SELECT o FROM OrderTran o " +
        "LEFT JOIN FETCH o.orderDetails " +
        "WHERE o.customerId = :customerId", 
        OrderTran.class);
    query.setParameter("customerId", customerId);
    return query.getResultList();
}
```

### 9.5 NamedQuery（再利用可能クエリ）

```java
@Entity
@NamedQueries({
    @NamedQuery(
        name = "Book.findAll",
        query = "SELECT b FROM Book b"
    ),
    @NamedQuery(
        name = "Book.findByCategory",
        query = "SELECT b FROM Book b WHERE b.category.categoryId = :categoryId"
    )
})
public class Book {
    // ...
}
```

```java
// 使用例
public List<Book> findAll() {
    TypedQuery<Book> query = em.createNamedQuery("Book.findAll", Book.class);
    return query.getResultList();
}
```

---

## 10. 他システム接続方式

### 10.1 REST API連携

#### 10.1.1 JAX-RS Clientの使用

```java
@ApplicationScoped
public class ExternalApiClient {
    private static final Logger logger = LoggerFactory.getLogger(ExternalApiClient.class);

    private Client client;
    private WebTarget target;

    @PostConstruct
    public void init() {
        client = ClientBuilder.newClient();
        target = client.target("https://api.example.com/v1");
    }

    public CustomerData getCustomer(String customerId) {
        logger.info("[ ExternalApiClient#getCustomer ] id={}", customerId);
        
        Response response = target
            .path("/customers/{id}")
            .resolveTemplate("id", customerId)
            .request(MediaType.APPLICATION_JSON)
            .header("Authorization", "Bearer " + getAccessToken())
            .get();

        if (response.getStatus() == 200) {
            return response.readEntity(CustomerData.class);
        } else {
            throw new RuntimeException("API call failed: " + response.getStatus());
        }
    }

    @PreDestroy
    public void cleanup() {
        if (client != null) {
            client.close();
        }
    }

    private String getAccessToken() {
        // トークン取得ロジック
        return "access_token";
    }
}
```

#### 10.1.2 設定の外部化

```java
@ApplicationScoped
public class ExternalApiClient {

    @Inject
    @ConfigProperty(name = "external.api.base-url")
    private String baseUrl;

    @Inject
    @ConfigProperty(name = "external.api.timeout", defaultValue = "5000")
    private Integer timeout;

    @PostConstruct
    public void init() {
        client = ClientBuilder.newBuilder()
            .connectTimeout(timeout, TimeUnit.MILLISECONDS)
            .readTimeout(timeout, TimeUnit.MILLISECONDS)
            .build();
        target = client.target(baseUrl);
    }
}
```

### 10.2 メッセージング（Jakarta Messaging - JMS）

```java
@ApplicationScoped
public class OrderMessageSender {

    @Resource(lookup = "java:/jms/queue/OrderQueue")
    private Queue orderQueue;

    @Inject
    private JMSContext context;

    public void sendOrderMessage(OrderTran order) {
        String message = toJson(order);
        context.createProducer().send(orderQueue, message);
    }

    private String toJson(OrderTran order) {
        // JSON変換処理
        return "{}";
    }
}
```

---

## 11. エラー・例外ハンドリング方式

### 11.1 例外設計方針

#### 11.1.1 例外の分類

| 例外種別 | 用途 | 例 |
|---------|------|-----|
| **ビジネス例外** | 業務ルール違反（予期される例外） | `OutOfStockException`, `CustomerNotFoundException` |
| **システム例外** | システム障害（予期しない例外） | `RuntimeException`, `SQLException` |
| **検証例外** | 入力値検証エラー | `ConstraintViolationException` |

#### 11.1.2 ビジネス例外の定義

```java
public class OutOfStockException extends RuntimeException {
    private Integer bookId;
    private String bookName;

    public OutOfStockException(Integer bookId, String bookName, String message) {
        super(message);
        this.bookId = bookId;
        this.bookName = bookName;
    }

    public Integer getBookId() {
        return bookId;
    }

    public String getBookName() {
        return bookName;
    }
}
```

**設計ポイント：**
- `RuntimeException`を継承（チェック例外は使用しない）
- エラー情報をフィールドに保持（ログ・画面表示に利用）

### 11.2 JSFでの例外ハンドリング

#### 11.2.1 Beanでのハンドリング

```java
public String processOrder() {
    try {
        orderService.createOrder(orderTO);
        return "orderComplete?faces-redirect=true";
        
    } catch (OutOfStockException e) {
        logger.warn("在庫不足: bookId={}, bookName={}", e.getBookId(), e.getBookName());
        FacesContext.getCurrentInstance().addMessage(null,
            new FacesMessage(FacesMessage.SEVERITY_ERROR, 
                "在庫不足", 
                e.getBookName() + "の在庫が不足しています"));
        return null;  // 同じページに留まる
        
    } catch (Exception e) {
        logger.error("注文処理エラー", e);
        FacesContext.getCurrentInstance().addMessage(null,
            new FacesMessage(FacesMessage.SEVERITY_ERROR, 
                "システムエラー", 
                "予期しないエラーが発生しました"));
        return null;
    }
}
```

#### 11.2.2 グローバル例外ハンドラー（web.xml）

```xml
<error-page>
    <exception-type>java.lang.Exception</exception-type>
    <location>/error.xhtml</location>
</error-page>

<error-page>
    <error-code>404</error-code>
    <location>/error404.xhtml</location>
</error-page>

<error-page>
    <error-code>500</error-code>
    <location>/error500.xhtml</location>
</error-page>
```

### 11.3 REST APIでの例外ハンドリング

#### 11.3.1 ExceptionMapperの実装

```java
@Provider
public class CustomerExceptionMapper implements ExceptionMapper<RuntimeException> {

    @Override
    public Response toResponse(RuntimeException exception) {
        // ビジネス例外の分類
        if (exception instanceof CustomerNotFoundException) {
            return Response.status(Response.Status.NOT_FOUND)
                    .entity(new ErrorResponse("customer.not-found", exception.getMessage()))
                    .build();
                    
        } else if (exception instanceof CustomerExistsException) {
            return Response.status(Response.Status.CONFLICT)
                    .entity(new ErrorResponse("customer.exists", exception.getMessage()))
                    .build();
        }
        
        // その他のシステム例外
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                .entity(new ErrorResponse("internal.error", "予期しないエラーが発生しました"))
                .build();
    }
}
```

#### 11.3.2 エラーレスポンスDTO

```java
public record ErrorResponse(
    String code,
    String message
) {}
```

**レスポンス例：**

```json
{
  "code": "customer.not-found",
  "message": "指定されたメールアドレスは存在しません"
}
```

#### 11.3.3 HTTPステータスコード対応表

| HTTPステータス | 用途 | 例外 |
|--------------|------|------|
| 400 Bad Request | 入力値検証エラー | `ConstraintViolationException` |
| 401 Unauthorized | 認証エラー | `AuthenticationException` |
| 403 Forbidden | 認可エラー | `AuthorizationException` |
| 404 Not Found | リソース未存在 | `CustomerNotFoundException` |
| 409 Conflict | リソース重複 | `CustomerExistsException` |
| 500 Internal Server Error | システムエラー | `RuntimeException` |

---

## 12. 共通化方式

### 12.1 共通基底クラス

#### 12.1.1 共通DAOの抽象化（オプション）

```java
public abstract class BaseDao<T, ID> {
    
    @PersistenceContext(unitName = "bookstorePU")
    protected EntityManager em;

    private Class<T> entityClass;

    @SuppressWarnings("unchecked")
    public BaseDao() {
        Type type = getClass().getGenericSuperclass();
        ParameterizedType paramType = (ParameterizedType) type;
        this.entityClass = (Class<T>) paramType.getActualTypeArguments()[0];
    }

    public T findById(ID id) {
        return em.find(entityClass, id);
    }

    public void persist(T entity) {
        em.persist(entity);
    }

    public T merge(T entity) {
        return em.merge(entity);
    }

    public void remove(T entity) {
        em.remove(entity);
    }
}
```

```java
@ApplicationScoped
public class BookDao extends BaseDao<Book, Integer> {
    // 固有のクエリメソッドのみ実装
    public List<Book> findByCategory(Integer categoryId) {
        // ...
    }
}
```

**使用判断：**
- プロジェクト規模が大きい場合は有効
- 小規模プロジェクトでは逆に複雑化する可能性あり

### 12.2 共通ユーティリティ

#### 12.2.1 日付ユーティリティ

```java
public class DateUtil {
    
    private DateUtil() {}  // インスタンス化禁止

    public static LocalDate today() {
        return LocalDate.now();
    }

    public static LocalDateTime now() {
        return LocalDateTime.now();
    }

    public static String format(LocalDate date, String pattern) {
        return date.format(DateTimeFormatter.ofPattern(pattern));
    }
}
```

#### 12.2.2 文字列ユーティリティ

```java
public class StringUtil {
    
    private StringUtil() {}

    public static boolean isEmpty(String str) {
        return str == null || str.isEmpty();
    }

    public static String toLikePattern(String keyword) {
        return "%" + keyword + "%";
    }
}
```

#### 12.2.3 住所ユーティリティ

```java
public final class AddressUtil {
    
    private AddressUtil() {}  // インスタンス化禁止
    
    private static final String[] PREFECTURES = {
        "北海道", "青森県", "岩手県", "宮城県", "秋田県", 
        "山形県", "福島県", "茨城県", "栃木県", "群馬県", 
        "埼玉県", "千葉県", "東京都", "神奈川県", "新潟県", 
        "富山県", "石川県", "福井県", "山梨県", "長野県", 
        "岐阜県", "静岡県", "愛知県", "三重県", "滋賀県", 
        "京都府", "大阪府", "兵庫県", "奈良県", "和歌山県", 
        "鳥取県", "島根県", "岡山県", "広島県", "山口県", 
        "徳島県", "香川県", "愛媛県", "高知県", "福岡県", 
        "佐賀県", "長崎県", "熊本県", "大分県", "宮崎県", 
        "鹿児島県", "沖縄県"
    };

    /**
     * 住所が正しい都道府県名で始まるかチェックする
     * @param address 住所
     * @return 都道府県名で始まる場合true
     */
    public static boolean startsWithValidPrefecture(String address) {
        if (address == null || address.isBlank()) {
            return false;
        }
        for (String prefecture : PREFECTURES) {
            if (address.startsWith(prefecture)) {
                return true;
            }
        }
        return false;
    }
}
```

**使用例（Managed Beanでの手動バリデーション）:**

```java
@Named
@ViewScoped
public class CustomerBean implements Serializable {
    
    private String address;
    
    public String register() {
        // 住所の都道府県チェック
        if (!AddressUtil.startsWithValidPrefecture(address)) {
            FacesContext.getCurrentInstance().addMessage(null,
                new FacesMessage(FacesMessage.SEVERITY_ERROR, 
                    "住所エラー", 
                    "都道府県名が正しく入力されていません"));
            return null;
        }
        
        // 顧客登録処理
        customerService.registerCustomer(customer);
        return "success?faces-redirect=true";
    }
}
```

### 12.3 定数クラス

```java
public final class Constants {
    
    private Constants() {}

    // 決済方法
    public static final class SettlementType {
        public static final int CREDIT_CARD = 1;
        public static final int CASH_ON_DELIVERY = 2;
        public static final int BANK_TRANSFER = 3;
    }

    // 配送料（DeliveryFeeServiceで管理）
    public static final class DeliveryFee {
        public static final BigDecimal STANDARD = new BigDecimal("800");
        public static final BigDecimal OKINAWA = new BigDecimal("1700");
        public static final BigDecimal FREE_THRESHOLD = new BigDecimal("5000");
    }
}
```

---

## 13. ログ方式

### 13.1 ロギングフレームワーク

**標準：SLF4J + Logback（または JUL）**

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@ApplicationScoped
public class BookService {
    private static final Logger logger = LoggerFactory.getLogger(BookService.class);

    public Book getBook(Integer bookId) {
        logger.info("[ BookService#getBook ] bookId={}", bookId);
        // ...
    }
}
```

### 13.2 ログレベルの使い分け

| レベル | 用途 | 例 |
|-------|------|-----|
| **ERROR** | システムエラー、予期しない例外 | `logger.error("データベース接続エラー", e);` |
| **WARN** | 警告、業務例外 | `logger.warn("在庫不足: bookId={}", bookId);` |
| **INFO** | 主要処理の開始・終了 | `logger.info("[ BookService#search ] start");` |
| **DEBUG** | 詳細な処理内容、変数の値 | `logger.debug("categoryId={}, keyword={}", categoryId, keyword);` |
| **TRACE** | 非常に詳細なトレース情報 | `logger.trace("Query result: {}", resultList);` |

### 13.3 ログ出力パターン

#### 13.3.1 メソッド開始ログ

```java
public Book getBook(Integer bookId) {
    logger.info("[ BookService#getBook ] bookId={}", bookId);
    // ...
}
```

#### 13.3.2 例外ログ

```java
try {
    // 処理
} catch (SQLException e) {
    logger.error("データベースエラー", e);  // スタックトレースも出力
    throw new RuntimeException("データアクセスエラー", e);
}
```

#### 13.3.3 パフォーマンスログ

```java
public List<Book> searchBook(Integer categoryId) {
    long startTime = System.currentTimeMillis();
    
    List<Book> result = bookDao.findByCategory(categoryId);
    
    long elapsedTime = System.currentTimeMillis() - startTime;
    logger.info("[ BookService#searchBook ] elapsed={}ms, resultCount={}", 
                elapsedTime, result.size());
    
    return result;
}
```

### 13.4 ログ設定（logback.xml）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    
    <!-- コンソール出力 -->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- ファイル出力 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- ルートロガー -->
    <root level="INFO">
        <appender-ref ref="STDOUT" />
        <appender-ref ref="FILE" />
    </root>

    <!-- パッケージ別ログレベル -->
    <logger name="dev.berry" level="DEBUG" />
    <logger name="org.hibernate" level="INFO" />
    <logger name="org.hibernate.SQL" level="DEBUG" />  <!-- SQL出力 -->

</configuration>
```

---

## 14. 推奨技術スタック

| カテゴリ | 技術 | バージョン | 備考 |
|---------|------|----------|------|
| **基盤** | Jakarta EE | 10以上 | プラットフォーム標準 |
| **アプリケーションサーバー** | Payara Server | 6以上 | または WildFly, Open Liberty |
| **JDK** | Eclipse Temurin / Oracle JDK | 17以上 | Java 21推奨 |
| **依存性注入** | CDI (Jakarta CDI) | 4.0以上 | `@Inject`, `@ApplicationScoped` |
| **トランザクション** | JTA (Jakarta Transactions) | 2.0以上 | `@Transactional` |
| **永続化** | JPA (Jakarta Persistence) | 3.1以上 | EclipseLink実装 |
| **Webフレームワーク（MVC）** | JSF (Jakarta Server Faces) | 4.0以上 | Facelets |
| **REST API** | JAX-RS (Jakarta RESTful Web Services) | 3.1以上 | Jersey実装 |
| **JSON処理** | JSON-B (Jakarta JSON Binding) | 3.0以上 | Yasson実装 |
| **バリデーション** | Jakarta Bean Validation | 3.0以上 | Hibernate Validator実装 |
| **ロギング** | SLF4J | 2.0以上 | Logback実装 |
| **ビルドツール** | Gradle | 8以上 | または Maven |

---

## 15. プロジェクト開始時のチェックリスト

### 15.1 初期セットアップ

- [ ] JDK 17以上のインストール・設定
- [ ] Gradle 8以上のインストール（または Maven）
- [ ] アプリケーションサーバーのセットアップ（Payara/WildFly）
- [ ] データベースの選定・セットアップ
- [ ] IDEの設定（Eclipse/IntelliJ IDEA）

### 15.2 プロジェクト構成

- [ ] パッケージ構成の作成（config, web/resource, service, dao, entity, dto, exception）
- [ ] persistence.xmlの作成・設定
- [ ] web.xmlの作成（JSFの場合はfaces-config.xml）
- [ ] beans.xmlの作成（CDI有効化）
- [ ] build.gradle/pom.xmlの依存関係設定

### 15.3 開発標準

- [ ] 命名規約の確認（Bean, Service, Dao, Entity, DTO）
- [ ] ロギング方針の確認（SLF4J使用、ログレベル）
- [ ] 例外ハンドリング方針の確認（ビジネス例外・システム例外の分類）
- [ ] トランザクション方針の確認（@Transactional使用）
- [ ] 認証・認可方式の確認

### 15.4 品質管理

- [ ] 単体テストフレームワークの導入（JUnit 5, Mockito）
- [ ] コードフォーマッター設定
- [ ] 静的コード解析ツール（SonarQube等、オプション）
- [ ] CI/CD環境の構築（オプション）

---

## 16. まとめ

本ガイドラインは、Jakarta EE 10を基盤とした堅牢で保守性の高いWebアプリケーション開発を実現するための技術標準である。

### 16.1 重要原則

1. **レイヤーアーキテクチャの遵守**：プレゼンテーション→ビジネスロジック→データアクセスの階層構造を守る
2. **依存性注入の活用**：`@Inject`によるCDI管理で疎結合を実現
3. **宣言的トランザクション**：`@Transactional`でトランザクション境界を明示
4. **例外の適切な分類**：ビジネス例外とシステム例外を区別し、適切にハンドリング
5. **ロギングの徹底**：主要処理の開始・終了、例外発生時のログ出力

### 16.2 品質向上のポイント

- **コードの一貫性**：命名規約、パッケージ構成、処理パターンを統一
- **保守性**：責務の分離、適切なコメント、ログ出力で保守を容易に
- **拡張性**：インターフェース分離、疎結合設計で将来の変更に対応
- **セキュリティ**：認証・認可の実装、入力検証の徹底
- **パフォーマンス**：適切なトランザクション境界、N+1問題の回避、ロック戦略

本ガイドラインを遵守することで、チーム全体で統一された開発標準を維持し、高品質なシステムを構築できる。
